/** @license RTreeJS

RTreeJS, a JavaScript Tree library that helps to query, insert and delete Rectangles.

Copyright Â© 2020-2021 Subendra Kumar Sharma. All rights reserved. (jobs.sharma.subendra.kr@gmail.com)

This file is part of RTreeJS.

RTreeJS is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

RTreeJS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with RTreeJS.  If not, see <https://www.gnu.org/licenses/>.

Written by Subendra Kumar Sharma.

*/
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("Stack")):"function"==typeof define&&define.amd?define(["Stack"],e):"object"==typeof exports?exports.RTreeJS=e(require("Stack")):t.RTreeJS=e(t.Stack)}(window,(function(t){return function(t){var e={};function r(s){if(e[s])return e[s].exports;var i=e[s]={i:s,l:!1,exports:{}};return t[s].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,s){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(s,i,function(e){return t[e]}.bind(null,i));return s},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="assets",r(r.s=2)}([function(e,r){e.exports=t},function(t,e,r){},function(t,e,r){"use strict";r.r(e),r.d(e,"RTreeIterative",(function(){return M}));var s=r(0);const i=Math.sqrt(Number.MAX_SAFE_INTEGER)-1e6,o=t=>(t.x2-t.x1)*(t.x2-t.x1)+(t.y2-t.y1)*(t.y2-t.y1),n=(t,e)=>{const r=(t.x2-t.x1)*(t.x2-t.x1)+(t.y2-t.y1)*(t.y2-t.y1),s=(e.x2-e.x1)*(e.x2-e.x1)+(e.y2-e.y1)*(e.y2-e.y1);return r>s?r-s:s-r},c=(t,e)=>({x1:t.x1<e.x1?t.x1:e.x1,x2:t.x2>e.x2?t.x2:e.x2,y1:t.y1<e.y1?t.y1:e.y1,y2:t.y2>e.y2?t.y2:e.y2}),l=(t,e,r=0)=>{let s=i,o=0,n=i,c=0;for(let i=r;i<e;i++){const e=t[i];s=e.rect.x1<s?e.rect.x1:s,o=e.rect.x2>o?e.rect.x2:o,n=e.rect.y1<n?e.rect.y1:n,c=e.rect.y2>c?e.rect.y2:c}return{x1:s,x2:o,y1:n,y2:c}},p=(t,e)=>t.x1===e.x1&&t.x2===e.x2&&t.y1===e.y1&&t.y2===e.y2,h=(t,e)=>t.x1<=e.x1&&t.x2>=e.x2&&t.y1<=e.y1&&t.y2>=e.y2,a=(t,e)=>!(t.x1>=e.x2||e.x1>=t.x2||t.y1>=e.y2||e.y1>=t.y2),u=(t,e)=>!(t.x1>e.x2||e.x1>t.x2||t.y1>e.y2||e.y1>t.y2),y=(t,e,r)=>{let s=Number.MAX_SAFE_INTEGER,i=0;for(let o=0;o<r;o++){const r=t[o],l=n(c(r.rect,e),r.rect);l<s&&(s=l,i=o)}return i},d=(t,e,r)=>{for(let s=0;s<e;s++)if(p(t[s].rect,r.rect))return!0;return!1},k=(t,e,r)=>{for(let s=0;s<e;s++)if(p(t[s].rect,r))return s;return-1},f=(t={size:0,keys:[],pointers:[]},e)=>{for(let r=e;r<t.size-1;r++)t.keys[r]=t.keys[r+1],t.pointers[r]=t.pointers[r+1];t.size--},S=(t={size:0,keys:[],pointers:[]},e,r)=>{let s=Number.MAX_SAFE_INTEGER,i=-1,n=-1;const l=t.keys[e].rect;for(let p=0;p<t.size;p++){if(p===e||t.pointers[p].size===r)continue;const h=t.pointers[p].keys,a=t.pointers[p].size;for(let t=0;t<a;t++){const e=h[t].rect,r=o(c(l,e));r<s&&(s=r,i=p,n=t)}}if(-1!==i)return{ptr:i,ptrPtr:n}},v=(t={size:0,keys:[],pointers:[]},e,r)=>{var s;const i=t.pointers[r.ptr]||{size:0,keys:[],pointers:[]},o=i.keys[r.ptrPtr],n=i.pointers[r.ptrPtr];for(let t=r.ptrPtr;t<i.size-1;t++)i.keys[t]=i.keys[t+1],i.pointers[t]=i.pointers[t+1];i.size--,t.keys[r.ptr].rect=l(i.keys,i.size);const c=(null===(s=t.pointers[e])||void 0===s?void 0:s.size)||0,p=t.pointers[e]||{size:0,keys:[],pointers:[]};p.keys[c]=o,p.pointers[c]=n,p.size++,t.keys[e].rect=l(p.keys,p.size)},x=(t={size:0,keys:[],pointers:[]},e,r)=>{let s=-1,i=Number.MAX_SAFE_INTEGER,n={x1:-1,x2:-1,y1:-1,y2:-1};for(let r=0;r<t.size;r++){if(r===e)continue;const l=c(t.keys[r].rect,t.keys[e].rect),p=o(l);p<i&&(i=p,n=l,s=r)}if(-1===s)return void(t.size=0);t.keys[s].rect=n;const l=t.pointers[e]||{size:0,keys:[],pointers:[]},p=t.pointers[s]||{size:0,keys:[],pointers:[]};let h=0;for(;h<l.size;)p.keys[p.size]=l.keys[h],p.pointers[p.size]=l.pointers[h],h++,p.size++;for(let r=e;r<t.size-1;r++)t.keys[r]=t.keys[r+1],t.pointers[r]=t.pointers[r+1];t.size--},z=(t,e,r,s)=>{const i=t[r],o=e[r];t[r]=t[s],e[r]=e[s],t[s]=i,e[s]=o},g=(t={size:0,keys:[],pointers:[]},e,r,s)=>{const{keys:i=[],pointers:o=[]}=t||{};let n=0,c=0,l=Number.MAX_SAFE_INTEGER,p=0;i[s]=e,o[s]=r;for(const[t,e]of i.entries())e.rect.x2<l&&(l=e.rect.x2,n=t),e.rect.x1>p&&(p=e.rect.x1,c=t);z(i,o,0,n),z(i,o,s,c)},m=(t,e,r,s)=>{const i=new Array(s+1),o=new Array(s+1);let n=r,c=0;for(;n<s+1;)i[c]=t[n],o[c]=e[n],c++,n++;return{rightRd:i,rptrs:o,rightSize:c}},E=(t={size:0,keys:[],pointers:[]},e,r,s,i)=>{const{keys:n=[],pointers:p=[]}=t||{},h=[...n],a=[...p];g(t,e,r,s);const{rdArrY:u,nodeArrY:y}=((t,e,r,s,i)=>{let o=0,n=0,c=Number.MAX_SAFE_INTEGER,l=0;t[i]=r,e[i]=s;for(const[e,r]of t.entries())r.rect.y2<c&&(c=r.rect.y2,o=e),r.rect.y1>l&&(l=r.rect.y1,n=e);return z(t,e,0,o),z(t,e,i,n),{rdArrY:t,nodeArrY:e}})(h,a,e,r,s),d=n[0].rect;let k,f=Number.MAX_SAFE_INTEGER;const S=u[0].rect;let v,x,E,b=Number.MAX_SAFE_INTEGER,H=1;for(;H<s+1;){f=Number.MAX_SAFE_INTEGER,b=Number.MAX_SAFE_INTEGER,k=H,v=H;for(let t=H;t<=s;t++)x=c(d,n[t].rect),E=o(x),E<f&&(k=t,f=E),x=c(S,u[t].rect),E=o(x),E<b&&(v=t,b=E);z(n,p,H,k),z(u,y,H,v),H++}let T=i,M=i;if(s%2==0){let t=n[0].rect,e=o(t),r=n[i+1].rect,l=o(r),p=n[0].rect,h=o(t),a=n[i+1].rect,y=o(r);for(let r=1;r<i;r++)t=c(t,n[r].rect),e=o(t),p=c(p,u[r].rect),h=o(p);for(let t=i+2;t<=s;t++)r=c(r,n[t].rect),l=o(r),a=c(a,u[t].rect),y=o(a);o(c(t,n[i].rect))-e<o(c(r,n[i].rect))-l&&T++,o(c(p,u[i].rect))-h<o(c(a,u[i].rect))-y&&M++}return o(l(n,T-1))+o(l(n,s+1,T))<o(l(u,M-1))+o(l(u,s+1,M))?(t.size=T,m(n,p,T,s)):(t.size=M,t.keys=u,t.pointers=y,m(u,y,M,s))},b=(t={size:0,keys:[],pointers:[]},e,r,s,i)=>{const{keys:n=[],pointers:l=[]}=t||{};g(t,e,r,s);let p,h,a,u,y,d,k,f,S,v,x,E,b=n[0].rect,H=n[s].rect,T=1,M=s-1,A=o(b),N=o(H);for(;T<=M;)a=n[T].rect,u=n[M].rect,y=c(a,b),S=o(y),d=c(a,H),v=o(d),p=S-A>v-N,k=c(u,b),x=o(k),f=c(u,H),E=o(f),h=E-N>x-A,p&&h?(z(n,l,T,M),b=k,A=x,H=d,N=v,T++,M--):p||h?p?h?(T++,M--):(E>v?(z(n,l,T,M),H=d,N=v):(H=f,N=E),M--):(S>x?(z(n,l,T,M),b=k,A=x):(b=y,A=S),T++):(b=y,A=S,H=f,N=E,T++,M--);return((t={size:0,keys:[],pointers:[]},e,r,s,i)=>{let n=i;if(s%2==0){let t=e[0].rect,r=o(t),l=e[i+1].rect,p=o(l);for(let s=1;s<i;s++)t=c(t,e[s].rect),r=o(t);for(let t=i+2;t<=s;t++)l=c(l,e[t].rect),p=o(l);o(c(t,e[i].rect))-r<o(c(l,e[i].rect))-p&&n++}return t.size=n,m(e,r,n,s)})(t,n,l,s,i)},H=["green","purple","blue","orange","aqua","blueviolet","brown","cadetblue","yellow","violet","thistle","teal","steelblue","silver","sienna","sandybrown","salmon","saddlebrown","olive"],T=(t,e,r)=>{const i=((t,e,r)=>{if(!t)return[];const i=new s.ArrayStack,o=new s.ArrayStack;let n=0;for(o.push({node:{rect:l(t.keys,t.size)},HEIGHT:n}),i.push({node:t,ptr:-1,HEIGHT:n++});!i.isEmpty();){const t=i.peek(),{node:e}=t;if(e.pointers[0])t.ptr+1<e.size?(o.push({node:e.keys[t.ptr+1],HEIGHT:n}),i.push({node:e.pointers[++t.ptr],ptr:-1,HEIGHT:n++})):(i.pop(),n--);else{for(let t=0;t<e.size;t++)o.push({node:e.keys[t],HEIGHT:n});i.pop(),n--}}return o.getData()})(t);console.log("data",i);const o=H.length,n={},c=i.length;for(let t=0;t<c-1;t++)i[t].HEIGHT<o?n[i[t].HEIGHT]=H[i[t].HEIGHT]:n[i[t].HEIGHT]="black";n[r]="red";const p=Math.max(...i.map(t=>t.node.rect.x2)),h=Math.max(...i.map(t=>t.node.rect.y2)),a=i.map(t=>{const e=1e3*t.node.rect.x1/p+4*t.HEIGHT;let r=1e3*t.node.rect.x2/p;r=r>4*t.HEIGHT?r-4*t.HEIGHT:r;const s=1e3*t.node.rect.y1/h+4*t.HEIGHT;let i=1e3*t.node.rect.y2/h;i=i>4*t.HEIGHT?i-4*t.HEIGHT:i;return`<g transform="translate(${e}, ${s})">\n\t\t\t<rect width="${r-e>0?r-e:1}" height="${i-s>0?i-s:1}" stroke="${n[t.HEIGHT]}" stroke-width="2" fill-opacity="0"/>\n\t\t</g>`}).reduce((t,e)=>t+e,""),u=Object.keys(n).map((t,e)=>`<g transform="translate(${70*e+10}, 10)"><circle r="5" fill="${n[t]}"/><text dx="10" dy="5">height: ${e}</text></g>`);i.sort((t,e)=>t.HEIGHT-e.HEIGHT);return`<svg width="1020" height="1070"><g width="1000" height="1000" transform="translate(0, 0)">${u}</g>\n\t<rect transform="translate(2, 48)" width="1000" height="1000" stroke="black" stroke-width="2" fill-opacity="0"/>\n\t<g transform="translate(0, 50)">${a}</g></svg>\n\t<div style="margin: 16px;">\n\t<p>height 0 is not an actual node, its just a rect surrounding all the rects in root node.</p>\n\t<p>Non-leaf node have colours other then red.</p>\n\t<p>Leaf node is always Red.</p>\n\t</div>\n\t<div style="display: flex; flex-direction: column; margin: 16px;">${i.reduce((t,e)=>t+`<div style="display:flex;"><span style="flex: 1;">height: ${e.HEIGHT},</span><span style="flex: 1;">rect: x1: ${e.node.rect.x1},</span><span style="flex: 1;">x2: ${e.node.rect.x2},</span><span style="flex: 1;">y1: ${e.node.rect.y1},</span><span style="flex: 1;">y2: ${e.node.rect.y2}</span></div>`,"")}</div>\n\t`};var M=class{constructor(t){var e,r,i;if(this.options=t,this.M=t.M||4,this.M%2==0?this.m=this.M/2:this.m=Math.ceil(this.M/2),this.M<2)throw"Value of M cannot be less than 2";if((null==t?void 0:t.m)&&Number.isInteger(t.m)&&t.m<=Math.ceil(this.M/2)&&t.m>=1)this.m=t.m;else if(null==t?void 0:t.m)throw"Can't hard set value of m for M, invalid value of m provided";this.splitNode=E,"linear"===(null==t?void 0:t.splitNode)&&(this.splitNode=b),this.root=void 0,this.length=0,this.height=0,this.initialStackSize=2*(null===(e=null==t?void 0:t.data)||void 0===e?void 0:e.length)||(null==t?void 0:t.initialStackSize)||100,this.initialQueueSize=2*(null===(r=null==t?void 0:t.data)||void 0===r?void 0:r.length)||(null==t?void 0:t.initialQueueSize)||100,this.insertStack=new s.ArrayStack({initialSize:this.initialStackSize}),this.ptrStack=new s.ArrayStack({initialSize:this.initialStackSize}),this.resultStack=new s.ArrayStack({initialSize:this.initialStackSize}),Array.isArray(null==t?void 0:t.data)&&this.constructTree(t.data),null===(i=this.options)||void 0===i||delete i.data}getRoot(){return this.root}constructNode(t,e,r,s){const i={size:0,pointers:new Array(this.M+1),keys:new Array(this.M+1)};return t?(i.keys[0]=t,i.pointers[0]=void 0,i.size=1):e&&r&&(i.keys=e,i.pointers=r,i.size=s||0),i}constructTree(t){const e=t.length;for(let r=0;r<e;r++)this.insert(t[r])}insert(t){return this._insert(t)}_insert(t){var e,r,s,i,o,n,c,p;let h,a=!1;if(this.insertStack.empty(),void 0===this.root)return this.root=this.constructNode(t),this.length++,this.height++,this.root;for(this.insertStack.push({node:this.root,pos:-1});!this.insertStack.isEmpty();){const o=this.insertStack.peek(),n=o.node;if(a)if(h){const t=l((null===(e=null==h?void 0:h.left)||void 0===e?void 0:e.keys)||[],(null===(r=null==h?void 0:h.left)||void 0===r?void 0:r.size)||0);n.keys[o.pos]={rect:t},n.pointers[o.pos]=null==h?void 0:h.left;const c=l((null===(s=null==h?void 0:h.right)||void 0===s?void 0:s.keys)||[],(null===(i=null==h?void 0:h.right)||void 0===i?void 0:i.size)||0);if(n.size<this.M)n.keys[n.size]={rect:c},n.pointers[n.size]=null==h?void 0:h.right,n.size++,h=void 0;else{const t=this.splitNode(n,{rect:c},h.right,this.M,this.m);h={left:n,right:this.constructNode(void 0,t.rightRd,t.rptrs,t.rightSize)}}this.insertStack.pop()}else n.keys[o.pos]={rect:l(n.pointers[o.pos].keys,n.pointers[o.pos].size)},this.insertStack.pop();else{if(null==n?void 0:n.pointers[0]){const e=y(n.keys,t.rect,n.size);o.pos=e,this.insertStack.push({node:n.pointers[e],pos:e});continue}if(d(n.keys,n.size,t))return;if(this.length++,n.size<this.M){n.keys[n.size]=t,n.size++,a=!0,this.insertStack.pop();continue}const e=this.splitNode(n,t,void 0,this.M,this.m);h={left:n,right:this.constructNode(void 0,e.rightRd,e.rptrs,e.rightSize)},a=!0,this.insertStack.pop()}}if(h){const t=l((null===(o=null==h?void 0:h.left)||void 0===o?void 0:o.keys)||[],(null===(n=null==h?void 0:h.left)||void 0===n?void 0:n.size)||0),e=l((null===(c=null==h?void 0:h.right)||void 0===c?void 0:c.keys)||[],(null===(p=null==h?void 0:h.right)||void 0===p?void 0:p.size)||0),r=this.constructNode();r&&(r.size=2,r.keys=[{rect:t},{rect:e}],r.pointers=[null==h?void 0:h.left,null==h?void 0:h.right],this.root=r),this.height++}}remove(t){return this._remove(t)}_remove(t){let e=!1;if(this.ptrStack.empty(),this.root)for(this.ptrStack.push({node:this.root,ptr:-1});!this.ptrStack.isEmpty();){const r=this.ptrStack.peek(),{node:s}=r;if(e)if(s.pointers[r.ptr].size<this.m){s.keys[r.ptr]={rect:l(s.pointers[r.ptr].keys,s.pointers[r.ptr].size)};const t=S(s,r.ptr,this.m);if(t)v(s,r.ptr,t);else if(x(s,r.ptr,this.m),s===this.root&&s.size<2){const t=this.root;this.root=t.pointers[0],t.keys=[];for(let e=0;e<this.M+1;e++)t.pointers[e]=void 0;this.height--,0===this.root.size&&(this.root=void 0,this.height=0,this.length=0)}this.ptrStack.pop()}else{const t=l(s.pointers[r.ptr].keys,s.pointers[r.ptr].size);s.keys[r.ptr]={rect:t},this.ptrStack.pop()}else if(s.pointers[0]){const e=r.ptr+1;for(let i=e;i<s.size;i++)if(h(s.keys[i].rect,t)){r.ptr=i,this.ptrStack.push({node:s.pointers[i],ptr:-1});break}r.ptr===e-1&&this.ptrStack.pop()}else{const r=k(s.keys,s.size,t);r>=0&&(f(s,r),e=!0,this.length--,s===this.root&&0===s.size&&(this.root=void 0,this.height=0,this.length=0)),this.ptrStack.pop()}}}find(t,e=!1,r=!1,s,i=!0){let o=a;return i&&(o=u),this._find(t,e,r,s,o)}_find(t,e=!1,r=!1,s,i){if(this.ptrStack.empty(),this.resultStack.empty(),!this.root&&r)return[];if(this.root){for(this.ptrStack.push({node:this.root,ptr:-1});!this.ptrStack.isEmpty();){const o=this.ptrStack.peek(),{node:n}=o;if(n.pointers[0]){const s=o.ptr+1;for(let c=s;c<n.size;c++)if(e&&!r?h(n.keys[c].rect,t):i(n.keys[c].rect,t)){o.ptr=c,this.ptrStack.push({node:n.pointers[c],ptr:-1});break}o.ptr===s-1&&this.ptrStack.pop()}else{for(let o=0;o<n.size;o++)if(e&&!r){if(p(n.keys[o].rect,t))return n.keys[o]}else if(r)!i(n.keys[o].rect,t)||s&&!s(n.keys[o],t)||this.resultStack.push(n.keys[o]);else if(i(n.keys[o].rect,t)&&(!s||s(n.keys[o],t)))return n.keys[o];this.ptrStack.pop()}}return this.resultStack.getData()}}getData(t=!1){if(!this.root)return[];for(this.ptrStack.empty(),this.resultStack.empty(),this.ptrStack.push({node:this.root,ptr:-1});!this.ptrStack.isEmpty();){const e=this.ptrStack.peek(),{node:r}=e;if(r.pointers[0])e.ptr+1<r.size?(this.ptrStack.push({node:r.pointers[++e.ptr],ptr:-1}),t&&this.resultStack.push(r.keys[e.ptr])):this.ptrStack.pop();else{for(let t=0;t<r.size;t++)this.resultStack.push(r.keys[t]);this.ptrStack.pop()}}return this.resultStack.getData()}reset(){this.root=void 0,this.length=0,this.height=0}emptyTree(){this.root=void 0,this.length=0,this.height=0;const t=Math.max(this.insertStack.stack.length,this.ptrStack.length,this.resultStack.length);for(let e=0;e<t;e++)this.insertStack.stack[e]&&(this.insertStack.stack[e].node=void 0),this.ptrStack.stack[e]&&(this.ptrStack.stack[e].node=void 0),this.resultStack.stack[e]&&(this.resultStack.stack[e]=void 0)}printTree(){return T(this.root,this.length,this.height)}};r(1),e.default=M}])}));