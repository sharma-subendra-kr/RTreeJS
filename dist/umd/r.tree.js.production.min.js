/** @license RTreeJS

RTreeJS, a JavaScript Tree library that helps to query, insert and delete Rectangles.

Copyright Â© 2020-2021 Subendra Kumar Sharma. All rights reserved. (jobs.sharma.subendra.kr@gmail.com)

This file is part of RTreeJS.

RTreeJS is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

RTreeJS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with RTreeJS.  If not, see <https://www.gnu.org/licenses/>.

Written by Subendra Kumar Sharma.

*/
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("Stack"),require("Queue")):"function"==typeof define&&define.amd?define(["Stack","Queue"],t):"object"==typeof exports?exports.RTreeJS=t(require("Stack"),require("Queue")):e.RTreeJS=t(e.Stack,e.Queue)}(window,(function(e,t){return function(e){var t={};function r(i){if(t[i])return t[i].exports;var s=t[i]={i:i,l:!1,exports:{}};return e[i].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=e,r.c=t,r.d=function(e,t,i){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)r.d(i,s,function(t){return e[t]}.bind(null,s));return i},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="assets",r(r.s=3)}([function(t,r){t.exports=e},function(e,r){e.exports=t},function(e,t,r){},function(e,t,r){"use strict";r.r(t),r.d(t,"RTreeIterative",(function(){return M}));var i=r(0),s=r(1);const o=Math.sqrt(Number.MAX_SAFE_INTEGER)-1e6,n=e=>(e.x2-e.x1)*(e.y2-e.y1),l=(e,t)=>({x1:e.x1<t.x1?e.x1:t.x1,x2:e.x2>t.x2?e.x2:t.x2,y1:e.y1<t.y1?e.y1:t.y1,y2:e.y2>t.y2?e.y2:t.y2}),p=(e,t)=>{let r=o,i=0,s=o,n=0;for(let o=0;o<t;o++){const t=e[o];r=t.rect.x1<r?t.rect.x1:r,i=t.rect.x2>i?t.rect.x2:i,s=t.rect.y1<s?t.rect.y1:s,n=t.rect.y2>n?t.rect.y2:n}return{x1:r,x2:i,y1:s,y2:n}},c=(e,t)=>e.x1===t.x1&&e.x2===t.x2&&e.y1===t.y1&&e.y2===t.y2,u=(e,t)=>e.x1<=t.x1&&e.x2>=t.x2&&e.y1<=t.y1&&e.y2>=t.y2,h=(e,t)=>!(e.x1>=t.x2||t.x1>=e.x2||e.y1>=t.y2||t.y1>=e.y2),d=(e,t)=>!(e.x1>t.x2||t.x1>e.x2||e.y1>t.y2||t.y1>e.y2),y=(e,t,r)=>{let i=Number.MAX_SAFE_INTEGER,s=0;for(let p=0;p<r;p++){const r=e[p],c=(o=l(r.rect,t),n=r.rect,(o.x2-o.x1)*(o.y2-o.y1)-(n.x2-n.x1)*(n.y2-n.y1));c<i&&(i=c,s=p)}var o,n;return s},a=(e,t,r)=>{for(let i=0;i<t;i++)if(c(e[i].rect,r.rect))return!0;return!1},f=(e,t,r)=>{for(let i=0;i<t;i++)if(c(e[i].rect,r))return i;return-1},k=(e={size:0,keys:[],pointers:[]},t)=>{for(let r=t;r<e.size-1;r++)e.keys[r]=e.keys[r+1],e.pointers[r]=e.pointers[r+1];e.size--},v=(e={size:0,keys:[],pointers:[]},t,r)=>{var i,s,o;let p,c=0,u=-1;for(let s=0;s<e.size;s++)s!==t&&((null===(i=e.pointers[s])||void 0===i?void 0:i.size)||-1)>r&&(p=n(e.keys[s].rect),p>c&&(c=p,u=s));let h=-1;if(u>=0){let r=Number.MAX_SAFE_INTEGER*Number.MAX_SAFE_INTEGER;const i=n(e.keys[t].rect);let p;for(let c=0;c<((null===(s=e.pointers[u])||void 0===s?void 0:s.size)||-1);c++)p=n(l((null===(o=e.pointers[u])||void 0===o?void 0:o.keys[c].rect)||{x1:Number.MAX_SAFE_INTEGER,x2:Number.MAX_SAFE_INTEGER,y1:Number.MAX_SAFE_INTEGER,y2:Number.MAX_SAFE_INTEGER},e.keys[t].rect)),Math.abs(p-i)<r&&(h=c,r=p)}if(h>=0)return{ptr:u,ptrPtr:h}},x=(e={size:0,keys:[],pointers:[]},t,r)=>{var i;const s=e.pointers[r.ptr]||{size:0,keys:[],pointers:[]},o=s.keys[r.ptrPtr].rect,n=s.pointers[r.ptrPtr];for(let e=r.ptrPtr;e<s.size-1;e++)s.keys[e]=s.keys[e+1],s.pointers[e]=s.pointers[e+1];s.size--,e.keys[r.ptr].rect=p(s.keys,s.size);const l=(null===(i=e.pointers[t])||void 0===i?void 0:i.size)||0,c=e.pointers[t]||{size:0,keys:[],pointers:[]};c.keys[l]={rect:o},c.pointers[l]=n,c.size++,e.keys[t].rect=p(c.keys,c.size)},z=(e={size:0,keys:[],pointers:[]},t,r)=>{let i=-1,s=Number.MAX_SAFE_INTEGER,o={x1:-1,x2:-1,y1:-1,y2:-1};for(let r=0;r<e.size;r++){if(r===t)continue;const p=l(e.keys[r].rect,e.keys[t].rect),c=n(p);c<s&&(s=c,o=p,i=r)}if(-1===i)return void(e.size=0);e.keys[i].rect=o;const p=e.pointers[t]||{size:0,keys:[],pointers:[]},c=e.pointers[i]||{size:0,keys:[],pointers:[]};let u=0;for(;u<p.size;)c.keys[c.size]=p.keys[u],c.pointers[c.size]=p.pointers[u],u++,c.size++;for(let r=t;r<e.size-1;r++)e.keys[r]=e.keys[r+1],e.pointers[r]=e.pointers[r+1];e.size--},g=(e,t,r,i)=>{const s=e[r],o=t[r];e[r]=e[i],t[r]=t[i],e[i]=s,t[i]=o},m=(e={size:0,keys:[],pointers:[]},t,r,i)=>{const{keys:s=[],pointers:o=[]}=e||{};let n=0,l=0,p=Number.MAX_SAFE_INTEGER,c=0;s[i]=t,o[i]=r;for(const[e,t]of s.entries())t.rect.x2<p&&(p=t.rect.x2,n=e),t.rect.x1>c&&(c=t.rect.x1,l=e);g(s,o,0,n),g(s,o,i,l)},E=(e={size:0,keys:[],pointers:[]},t,r,i,s)=>{const o=s;e.size=o;const n=new Array(i+1),l=new Array(i+1);let p=o,c=0;for(;p<i+1;)n[c]=t[p],l[c]=r[p],c++,p++;return{rightRd:n,rptrs:l,rightSize:c}},S=(e={size:0,keys:[],pointers:[]},t,r,i,s)=>{const{keys:o=[],pointers:p=[]}=e||{};m(e,t,r,i);const c=o[0].rect;let u,h,d,y=Number.MAX_SAFE_INTEGER,a=1;for(;a<i+1;){y=Number.MAX_SAFE_INTEGER,u=a;for(let e=a;e<=i;e++)h=l(c,o[e].rect),d=n(h),d<y&&(u=e,y=d);g(o,p,a,u),a++}return E(e,o,p,i,s)},b=(e={size:0,keys:[],pointers:[]},t,r,i,s)=>{const{keys:o=[],pointers:p=[]}=e||{};m(e,t,r,i);let c,u,h,d,y,a,f,k,v,x,z,S,b=o[0].rect,A=o[i].rect,T=1,M=i-1,N=n(b),_=n(A);for(;T<=M;)h=o[T].rect,d=o[M].rect,y=l(h,b),v=n(y),a=l(h,A),x=n(a),c=v-N>x-_,f=l(d,b),z=n(f),k=l(d,A),S=n(k),u=S-_>z-N,c&&u?(g(o,p,T,M),b=f,N=z,A=a,_=x,T++,M--):c||u?c?(S>x?(g(o,p,T,M),A=a,_=x):(A=k,_=S),M--):(v>z?(g(o,p,T,M),b=f,N=z):(b=y,N=v),T++):(b=y,N=v,A=k,_=S,T++,M--),T++,M--;return E(e,o,p,i,s)},A=["green","purple","blue","orange","aqua","blueviolet","brown","cadetblue","yellow","violet","thistle","teal","steelblue","silver","sienna","sandybrown","salmon","saddlebrown","olive"],T=(e,t,r)=>{var s;const o=((e,t,r)=>{if(!e)return[];const s=new i.ArrayStack,o=new i.ArrayStack;let n=0;for(o.push({node:{rect:p(e.keys,e.size)},HEIGHT:n}),s.push({node:e,ptr:-1,HEIGHT:n++});!s.isEmpty();){const e=s.peek(),{node:t}=e;if(t.pointers[0])e.ptr+1<t.size?(o.push({node:t.keys[e.ptr+1],HEIGHT:n}),s.push({node:t.pointers[++e.ptr],ptr:-1,HEIGHT:n++})):(s.pop(),n--);else{for(let e=0;e<t.size;e++)o.push({node:t.keys[e],HEIGHT:n});s.pop(),n--}}return o.getData()})(e);console.log("data",o);const n=A.length,l={},c=o.length;for(let e=0;e<c-1;e++)o[e].HEIGHT<n?l[o[e].HEIGHT]=A[o[e].HEIGHT]:l[o[e].HEIGHT]="black";l[r]="red";const u=(null===(s=o[0])||void 0===s?void 0:s.node.rect.x2)-0,h=o.map(e=>{const t=600*e.node.rect.x1/u+4*e.HEIGHT,r=600*e.node.rect.x2/u-4*e.HEIGHT,i=600*e.node.rect.y1/u+4*e.HEIGHT;return`<g transform="translate(${t}, ${i})">\n\t\t\t<rect width="${r-t}" height="${600*e.node.rect.y2/u-4*e.HEIGHT-i}" stroke="${l[e.HEIGHT]}" stroke-width="2" fill-opacity="0"/>\n\t\t</g>`}).reduce((e,t)=>e+t,""),d=Object.keys(l).map((e,t)=>`<g transform="translate(${70*t+10}, 10)"><circle r="5" fill="${l[e]}"/><text dx="10" dy="5">height: ${t}</text></g>`);o.sort((e,t)=>e.HEIGHT-t.HEIGHT);return`<svg width="620" height="670"><g width="600" height="600" transform="translate(0, 0)">${d}</g>\n\t<rect transform="translate(2, 48)" width="600" height="600" stroke="black" stroke-width="2" fill-opacity="0"/>\n\t<g transform="translate(0, 50)">${h}</g></svg>\n\t<div style="margin: 16px;">\n\t<p>height 0 is not an actual node, its just a rect surrounding all the rects in root node.</p>\n\t<p>Non-leaf node have colours other then red.</p>\n\t<p>Leaf node is always Red.</p>\n\t</div>\n\t<div style="display: flex; flex-direction: column; margin: 16px;">${o.reduce((e,t)=>e+`<div style="display:flex;"><span style="flex: 1;">height: ${t.HEIGHT},</span><span style="flex: 1;">rect: x1: ${t.node.rect.x1},</span><span style="flex: 1;">x2: ${t.node.rect.x2},</span><span style="flex: 1;">y1: ${t.node.rect.y1},</span><span style="flex: 1;">y2: ${t.node.rect.y2}</span></div>`,"")}</div>\n\t`};var M=class{constructor(e){var t,r,o;if(this.options=e,this.M=e.M||4,this.M%2==0?this.m=this.M/2:this.m=Math.ceil(this.M/2),this.M<2)throw"Value of M cannot be less than 2";if((null==e?void 0:e.m)&&Number.isInteger(e.m)&&e.m<=Math.ceil(this.M/2)&&e.m>=1)this.m=e.m;else if(null==e?void 0:e.m)throw"Can't hard set value of m for M, invalid value of m provided";this.splitNode=S,"linear"===(null==e?void 0:e.splitNode)&&(this.splitNode=b),this.root=void 0,this.length=0,this.height=0,this.initialStackSize=2*(null===(t=null==e?void 0:e.data)||void 0===t?void 0:t.length)||(null==e?void 0:e.initialStackSize)||500,this.initialQueueSize=2*(null===(r=null==e?void 0:e.data)||void 0===r?void 0:r.length)||(null==e?void 0:e.initialQueueSize)||500,this.queue=new s.ArrayQueue({initialSize:this.initialQueueSize}),this.stack=new i.ArrayStack({initialSize:this.initialStackSize}),Array.isArray(null==e?void 0:e.data)&&this.constructTree(e.data),null===(o=this.options)||void 0===o||delete o.data}getRoot(){return this.root}constructNode(e,t,r,i){const s={size:0,pointers:new Array(this.M+1),keys:new Array(this.M+1)};return e?(s.keys[0]=e,s.pointers[0]=void 0,s.size=1):t&&r&&(s.keys=t,s.pointers=r,s.size=i||0),s}constructTree(e){const t=e.length;for(let r=0;r<t;r++)this.insert(e[r])}insert(e){return this._insert(e)}_insert(e){var t,r,s,o,n,l,c,u;let h,d=!1;const f=new i.ArrayStack;if(void 0===this.root)return this.root=this.constructNode(e),this.length++,this.height++,this.root;for(f.push({node:this.root,pos:-1});!f.isEmpty();){const i=f.peek(),n=i.node;if(d)if(h){const e=p((null===(t=null==h?void 0:h.left)||void 0===t?void 0:t.keys)||[],(null===(r=null==h?void 0:h.left)||void 0===r?void 0:r.size)||0);n.keys[i.pos]={rect:e},n.pointers[i.pos]=null==h?void 0:h.left;const l=p((null===(s=null==h?void 0:h.right)||void 0===s?void 0:s.keys)||[],(null===(o=null==h?void 0:h.right)||void 0===o?void 0:o.size)||0);if(n.size<this.M)n.keys[n.size]={rect:l},n.pointers[n.size]=null==h?void 0:h.right,n.size++,h=void 0;else{const e=this.splitNode(n,{rect:l},h.right,this.M,this.m);h={left:n,right:this.constructNode(void 0,e.rightRd,e.rptrs,e.rightSize)}}f.pop()}else n.keys[i.pos]={rect:p(n.pointers[i.pos].keys,n.pointers[i.pos].size)},f.pop();else{if(null==n?void 0:n.pointers[0]){const t=y(n.keys,e.rect,n.size);i.pos=t,f.push({node:n.pointers[t],pos:t});continue}if(a(n.keys,n.size,e))return;if(this.length++,n.size<this.M){n.keys[n.size]=e,n.size++,d=!0,f.pop();continue}const t=this.splitNode(n,e,void 0,this.M,this.m);h={left:n,right:this.constructNode(void 0,t.rightRd,t.rptrs,t.rightSize)},d=!0,f.pop()}}if(h){const e=p((null===(n=null==h?void 0:h.left)||void 0===n?void 0:n.keys)||[],(null===(l=null==h?void 0:h.left)||void 0===l?void 0:l.size)||0),t=p((null===(c=null==h?void 0:h.right)||void 0===c?void 0:c.keys)||[],(null===(u=null==h?void 0:h.right)||void 0===u?void 0:u.size)||0),r=this.constructNode();r&&(r.size=2,r.keys=[{rect:e},{rect:t}],r.pointers=[null==h?void 0:h.left,null==h?void 0:h.right],this.root=r),this.height++}}remove(e){return this._remove(e)}_remove(e){let t=!1;const r=new i.ArrayStack;if(this.root)for(r.push({node:this.root,ptr:-1});!r.isEmpty();){const i=r.peek(),{node:s}=i;if(t)if(s.pointers[i.ptr].size<this.m){s.keys[i.ptr]={rect:p(s.pointers[i.ptr].keys,s.pointers[i.ptr].size)};const e=v(s,i.ptr,this.m);if(e)x(s,i.ptr,e);else if(z(s,i.ptr,this.m),s===this.root&&s.size<2){const e=this.root;this.root=e.pointers[0],e.keys=[];for(let t=0;t<this.M+1;t++)e.pointers[t]=void 0;this.height--,0===this.root.size&&(this.root=void 0,this.height=0,this.length=0)}r.pop()}else{const e=p(s.pointers[i.ptr].keys,s.pointers[i.ptr].size);s.keys[i.ptr]={rect:e},r.pop()}else if(s.pointers[0]){const t=i.ptr+1;for(let o=t;o<s.size;o++)if(u(s.keys[o].rect,e)){i.ptr=o,r.push({node:s.pointers[o],ptr:-1});break}i.ptr===t-1&&r.pop()}else{const i=f(s.keys,s.size,e);i>=0&&(k(s,i),t=!0,this.length--,s===this.root&&0===s.size&&(this.root=void 0,this.height=0,this.length=0)),r.pop()}}}find(e,t=!1,r=!1,i,s=!0){let o=h;return s&&(o=d),this._find(e,t,r,i,o)}_find(e,t=!1,r=!1,s,o){const n=new i.ArrayStack,l=new i.ArrayStack;if(!this.root&&r)return[];if(this.root){for(n.push({node:this.root,ptr:-1});!n.isEmpty();){const i=n.peek(),{node:p}=i;if(p.pointers[0]){const s=i.ptr+1;for(let l=s;l<p.size;l++)if(t&&!r?u(p.keys[l].rect,e):o(p.keys[l].rect,e)){i.ptr=l,n.push({node:p.pointers[l],ptr:-1});break}i.ptr===s-1&&n.pop()}else{for(let i=0;i<p.size;i++)if(t&&!r){if(c(p.keys[i].rect,e))return p.keys[i]}else if(r)!o(p.keys[i].rect,e)||s&&!s(p.keys[i],e)||l.push(p.keys[i]);else if(o(p.keys[i].rect,e)&&(!s||s(p.keys[i],e)))return p.keys[i];n.pop()}}return l.getData()}}getData(){if(!this.root)return[];const e=new i.ArrayStack,t=new i.ArrayStack;for(e.push({node:this.root,ptr:-1});!e.isEmpty();){const r=e.peek(),{node:i}=r;if(i.pointers[0])r.ptr+1<i.size?e.push({node:i.pointers[++r.ptr],ptr:-1}):e.pop();else{for(let e=0;e<i.size;e++)t.push(i.keys[e]);e.pop()}}return t.getData()}reset(){this.root=void 0,this.length=0,this.height=0}emptyTree(){this.root=void 0,this.length=0,this.height=0}printTree(){return T(this.root,this.length,this.height)}};r(2),t.default=M}])}));