/** @license RTreeJS

RTreeJS, a JavaScript Tree library that helps to query, insert and delete Rectangles.

Copyright Â© 2020-2021 Subendra Kumar Sharma. All rights reserved. (jobs.sharma.subendra.kr@gmail.com)

This file is part of RTreeJS.

RTreeJS is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

RTreeJS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with RTreeJS.  If not, see <https://www.gnu.org/licenses/>.

Written by Subendra Kumar Sharma.

*/
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("Stack"),require("Queue")):"function"==typeof define&&define.amd?define(["Stack","Queue"],t):"object"==typeof exports?exports.RTreeJS=t(require("Stack"),require("Queue")):e.RTreeJS=t(e.Stack,e.Queue)}(window,(function(e,t){return function(e){var t={};function i(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=e,i.c=t,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)i.d(r,o,function(t){return e[t]}.bind(null,o));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="assets",i(i.s=3)}([function(t,i){t.exports=e},function(e,i){e.exports=t},function(e,t,i){},function(e,t,i){"use strict";i.r(t),i.d(t,"RTreesIterative",(function(){return x}));var r=i(0),o=i(1);const s=Math.sqrt(Number.MAX_SAFE_INTEGER)-1e6,n=e=>(e.x2-e.x1)*(e.y2-e.y1),l=(e,t)=>({x1:e.x1<t.x1?e.x1:t.x1,x2:e.x2>t.x2?e.x2:t.x2,y1:e.y1<t.y1?e.y1:t.y1,y2:e.y2>t.y2?e.y2:t.y2}),u=(e,t)=>{let i=s,r=0,o=s,n=0;for(let s=0;s<t;s++){const t=e[s];i=t.rect.x1<i?t.rect.x1:i,r=t.rect.x2>r?t.rect.x2:r,o=t.rect.y1<o?t.rect.y1:o,n=t.rect.y2>n?t.rect.y2:n}return{x1:i,x2:r,y1:o,y2:n}},c=(e,t)=>e.x1===t.x1&&e.x2===t.x2&&e.y1===t.y1&&e.y2===t.y2,p=(e,t)=>e.x1<=t.x1&&e.x2>=t.x2&&e.y1<=t.y1&&e.y2>=t.y2,y=(e,t,i)=>{let r=Number.MAX_SAFE_INTEGER,o=0;for(let u=0;u<i;u++){const i=e[u],c=(s=l(i.rect,t),n=i.rect,(s.x2-s.x1)*(s.y2-s.y1)-(n.x2-n.x1)*(n.y2-n.y1));c<r&&(r=c,o=u)}var s,n;return o},d=(e,t,i)=>{for(let r=0;r<t;r++)if(c(e[r].rect,i.rect))return!0;return!1},f=(e={size:0,keys:[],pointers:[],next:void 0},t,i,r)=>{const{keys:o=[],pointers:s=[]}=e||{};let u=0,c=0,p=Number.MAX_SAFE_INTEGER,y=0;for(const[e,t]of o.entries())t.rect.x2<p&&(p=t.rect.x2,u=e),t.rect.x1>y&&(y=t.rect.x1,c=e);let d=o[0],f=s[0];o[0]=o[u],s[0]=s[u],o[u]=d,s[u]=f,d=o[r-1],f=s[r-1],o[r-1]=o[c],s[r-1]=s[c],o[c]=d,s[c]=f;let v,a,h,k,z,x,S,m,E,A,M,_,b=o[0].rect,g=o[r-1].rect,N=1,R=r-2,T=n(b),w=n(g);for(;N<R;)if(h=o[N].rect,k=o[R].rect,z=l(h,b),E=n(z),x=l(h,g),A=n(x),v=E-T>A-w,S=l(k,b),M=n(S),m=l(k,g),_=n(m),a=_-w>M-T,v&&a){const e=o[N],t=s[N];o[N]=o[R],s[N]=s[R],o[R]=e,s[R]=t,b=S,T=M,g=x,w=A,N++,R--}else v||a?v?(g=m,w=_,R--):(b=z,T=E,N++):(b=z,T=E,g=m,w=_,N++,R--);let I=N;e.size=I,N===R&&(z=l(o[N].rect,b),E=n(z),x=l(o[N].rect,g),A=n(x),E<A?(b=z,T=E,I++,e.size++):(g=x,w=A));const j=new Array(r),F=new Array(r);let G=I,X=0;for(;G<r;)j[X]=o[G],F[X]=s[G],X++,G++;return n(l(t.rect,b))-T<n(l(t.rect,g))-w?(o[e.size]=t,s[e.size]=i,e.size++):(j[X]=t,F[X]=i,X++),{rightRd:j,rptrs:F,rightSize:X}},v=(e,t,i)=>{for(let r=0;r<t;r++)if(c(e[r].rect,i))return r;return-1},a=(e={size:0,keys:[],pointers:[],next:void 0},t)=>{for(let i=t;i<e.size-1;i++)e.keys[i]=e.keys[i+1],e.pointers[i]=e.pointers[i+1];e.size--},h=(e={size:0,keys:[],pointers:[],next:void 0},t,i)=>{var r,o,s;let u,c=0,p=-1;for(let o=0;o<e.size;o++)o!==t&&((null===(r=e.pointers[o])||void 0===r?void 0:r.size)||-1)>i&&(u=n(e.keys[o].rect),u>c&&(c=u,p=o));let y=-1;if(p>=0){let i=Number.MAX_SAFE_INTEGER*Number.MAX_SAFE_INTEGER;const r=n(e.keys[t].rect);let u;for(let c=0;c<((null===(o=e.pointers[p])||void 0===o?void 0:o.size)||-1);c++)u=n(l((null===(s=e.pointers[p])||void 0===s?void 0:s.keys[c].rect)||{x1:Number.MAX_SAFE_INTEGER,x2:Number.MAX_SAFE_INTEGER,y1:Number.MAX_SAFE_INTEGER,y2:Number.MAX_SAFE_INTEGER},e.keys[t].rect)),Math.abs(u-r)<i&&(y=c,i=u)}if(y>=0)return{ptr:p,ptrPtr:y}},k=(e={size:0,keys:[],pointers:[],next:void 0},t,i)=>{var r;const o=e.pointers[i.ptr]||{size:0,keys:[],pointers:[],next:void 0},s=o.keys[i.ptrPtr].rect,n=o.pointers[i.ptrPtr];for(let e=i.ptrPtr;e<o.size-1;e++)o.keys[e]=o.keys[e+1],o.pointers[e]=o.pointers[e+1];o.size--,e.keys[i.ptr].rect=u(o.keys,o.size);const l=(null===(r=e.pointers[t])||void 0===r?void 0:r.size)||0,c=e.pointers[t]||{size:0,keys:[],pointers:[],next:void 0};c.keys[l]={rect:s},c.pointers[l]=n,c.size++,e.keys[t].rect=u(c.keys,c.size)},z=(e={size:0,keys:[],pointers:[],next:void 0},t,i)=>{let r=-1,o=Number.MAX_SAFE_INTEGER,s={x1:-1,x2:-1,y1:-1,y2:-1};for(let i=0;i<e.size;i++){if(i===t)continue;const u=l(e.keys[i].rect,e.keys[t].rect),c=n(u);c<o&&(o=c,s=u,r=i)}e.keys[r].rect=s;const u=e.pointers[t]||{size:0,keys:[],pointers:[],next:void 0},c=e.pointers[r]||{size:0,keys:[],pointers:[],next:void 0};let p=0;for(;p<u.size;)c.keys[c.size]=u.keys[p],c.pointers[c.size]=u.pointers[p],p++,c.size++;for(let i=t;i<e.size-1;i++)e.keys[i]=e.keys[i+1],e.pointers[i]=e.pointers[i+1];e.size--};var x=class{constructor(e){var t,i,s;if(this.options=e,this.M=e.M||4,this.m=Math.ceil(this.M/2)-1,this.M<3)throw"Value of M cannot be less than 2";if((null==e?void 0:e.m)&&this.M>3)this.m=e.m;else if(null==e?void 0:e.m)throw"Can't hard set value of m for M equals 3";this.root=void 0,this.length=0,this.initialStackSize=2*(null===(t=null==e?void 0:e.data)||void 0===t?void 0:t.length)||(null==e?void 0:e.initialStackSize)||500,this.initialQueueSize=2*(null===(i=null==e?void 0:e.data)||void 0===i?void 0:i.length)||(null==e?void 0:e.initialQueueSize)||500,this.queue=new o.ArrayQueue({initialSize:this.initialQueueSize}),this.stack=new r.ArrayStack({initialSize:this.initialStackSize}),Array.isArray(null==e?void 0:e.data)&&this.constructTree(e.data),null===(s=this.options)||void 0===s||delete s.data}getRoot(){return this.root}constructNode(e,t,i,r){const o={size:0,pointers:new Array(this.M),keys:new Array(this.M),next:void 0};return e?(o.keys[0]=e,o.pointers[0]=void 0,o.size=1):t&&i&&(o.keys=t,o.pointers=i,o.size=r||0),o}constructTree(e){const t=e.length;for(let i=0;i<t;i++)this.insert(e[i])}insert(e){return this._insert(e)}_insert(e){var t,i,o,s,n,l,c,p;let v,a=!1;const h=new r.ArrayStack;if(void 0===this.root)return this.root=this.constructNode(e),this.root;for(h.push({node:this.root,pos:-1});!h.isEmpty();){const r=h.peek(),n=r.node;if(a)if(v){const e=u((null===(t=null==v?void 0:v.left)||void 0===t?void 0:t.keys)||[],(null===(i=null==v?void 0:v.left)||void 0===i?void 0:i.size)||0);n.keys[r.pos]={rect:e},n.pointers[r.pos]=null==v?void 0:v.left;const l=u((null===(o=null==v?void 0:v.right)||void 0===o?void 0:o.keys)||[],(null===(s=null==v?void 0:v.right)||void 0===s?void 0:s.size)||0);if(n.size<this.M)n.keys[n.size]={rect:l},n.pointers[n.size]=null==v?void 0:v.right,n.size++,v=void 0;else{const e=f(n,{rect:l},v.right,this.M);v={left:n,right:this.constructNode(void 0,e.rightRd,e.rptrs,e.rightSize)},a=!0}h.pop()}else n.keys[r.pos]={rect:u(n.pointers[r.pos].keys,n.pointers[r.pos].size)},h.pop();else{if(null==n?void 0:n.pointers[0]){const t=y(n.keys,e.rect,n.size);r.pos=t,h.push({node:n.pointers[t],pos:t});continue}if(d(n.keys,n.size,e))return;if(n.size<this.M){n.keys[n.size]=e,n.size++,a=!0,h.pop();continue}const t=f(n,e,void 0,this.M);v={left:n,right:this.constructNode(void 0,t.rightRd,t.rptrs,t.rightSize)},a=!0,h.pop()}}if(v){const e=u((null===(n=null==v?void 0:v.left)||void 0===n?void 0:n.keys)||[],(null===(l=null==v?void 0:v.left)||void 0===l?void 0:l.size)||0),t=u((null===(c=null==v?void 0:v.right)||void 0===c?void 0:c.keys)||[],(null===(p=null==v?void 0:v.right)||void 0===p?void 0:p.size)||0),i=this.constructNode();i&&(i.size=2,i.keys=[{rect:e},{rect:t}],i.pointers=[null==v?void 0:v.left,null==v?void 0:v.right],this.root=i)}}remove(e){return this._remove(e)}_remove(e){let t=!1;const i=new r.ArrayStack;if(this.root)for(i.push({node:this.root,ptr:-1});!i.isEmpty();){const r=i.peek(),{node:o}=r;if(t)if(o.pointers[r.ptr].size<this.m){o.keys[r.ptr]={rect:u(o.pointers[r.ptr].keys,o.pointers[r.ptr].size)};const e=h(o,r.ptr,this.m);e?k(o,r.ptr,e):z(o,r.ptr,this.m),i.pop()}else{const e=u(o.pointers[r.ptr].keys,o.pointers[r.ptr].size);o.keys[r.ptr]={rect:e},i.pop()}else if(o.pointers[0]){const t=r.ptr+1;for(let s=t;s<o.size;s++)if(p(o.keys[s].rect,e)){r.ptr=s,i.push({node:o.pointers[s],ptr:-1});break}r.ptr===t-1&&i.pop()}else{const r=v(o.keys,o.size,e);r>=0&&(a(o,r),t=!0),i.pop()}}}};i(2);console.log(1);t.default=x}])}));